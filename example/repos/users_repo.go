// Code generated by bizdb. DO NOT EDIT.
package repos

import (
	"errors"
	"fmt"
	"time"

	"github.com/chslink/bizdb"
	"github.com/chslink/bizdb/example/models"
)

var (
	ErrUsersNotFound = errors.New("users not found")
)

type UsersRepo struct {
	memDB     *bizdb.MemoryDB
	tableName string
	tx        *bizdb.Transaction
}

// NewUsersRepo 创建普通Repository
func NewUsersRepo(memDB *bizdb.MemoryDB) *UsersRepo {
	return &UsersRepo{
		memDB:     memDB,
		tableName: "users",
	}
}

// WithTx 创建带事务的Repository
func (r *UsersRepo) WithTx(tx *bizdb.Transaction) *UsersRepo {
	return &UsersRepo{
		memDB:     r.memDB,
		tableName: r.tableName,
		tx:        tx,
	}
}

type UsersQuery struct {
	Id       *int64     `db:"id"`
	Name     *string    `db:"name"`
	Email    *string    `db:"email"`
	Age      *int64     `db:"age"`
	CreateAt *time.Time `db:"create_at"`
	Limit    *int
	Offset   *int
}

// GetById 根据主键获取
func (r *UsersRepo) GetById(Id int64) (*models.Users, error) {
	val, err := r.memDB.Get(r.tx, r.tableName, Id)
	if err != nil {
		return nil, err
	}

	if val == nil {
		return nil, ErrUsersNotFound
	}

	model, ok := val.(*models.Users)
	if !ok {
		return nil, fmt.Errorf("type assertion failed")
	}

	return model.Copy(), nil
}

// GetByEmail 根据唯一索引查询
func (r *UsersRepo) GetByEmail(val string) (*models.Users, error) {
	query := UsersQuery{
		Email: &val,
	}

	results, err := r.Query(query)
	if err != nil {
		return nil, err
	}

	if len(results) == 0 {
		return nil, ErrUsersNotFound
	}

	return results[0], nil
}

// Create 创建记录
func (r *UsersRepo) Create(model *models.Users) error {

	if existing, _ := r.memDB.Get(r.tx, r.tableName, model.Id); existing != nil {
		return fmt.Errorf("record with Id %v already exists", model.Id)
	}

	return r.memDB.Put(r.tx, r.tableName, model.Id, model.Copy())
}

// Update 更新记录
func (r *UsersRepo) Update(model *models.Users) error {
	return r.memDB.Put(r.tx, r.tableName, model.Id, model.Copy())
}

// Delete 删除记录
func (r *UsersRepo) Delete(Id int64) error {
	return r.memDB.Delete(r.tx, r.tableName, Id)
}

// Range 遍历查询
func (r *UsersRepo) Range(f func(Id int64, val *models.Users) bool) error {
	return r.memDB.Range(r.tx, r.tableName, func(id, val any) bool {
		return f(id.(int64), val.(*models.Users))
	})
}

// Query 高级查询
func (r *UsersRepo) Query(q UsersQuery) ([]*models.Users, error) {
	var results []*models.Users

	// 遍历匹配记录
	err := r.Range(func(Id int64, val *models.Users) bool {
		model := val

		// 组合查询条件（模板生成核心修改点）

		if (q.Id != nil && *q.Id != model.Id) || (q.Name != nil && *q.Name != model.Name) || (q.Email != nil && *q.Email != model.Email) || (q.Age != nil && *q.Age != model.Age) || (q.CreateAt != nil && *q.CreateAt != model.CreateAt) {
			return true // 不匹配则继续
		}

		results = append(results, model.Copy())
		return true
	})

	if err != nil {
		return nil, err
	}

	// 统一分页处理（模板结构调整）
	offset := 0
	if q.Offset != nil {
		offset = *q.Offset
	}

	limit := len(results) // 默认全量
	if q.Limit != nil {
		limit = *q.Limit
	}

	// 边界保护（新增模板逻辑）
	if offset < 0 {
		offset = 0
	}

	start := offset
	if start > len(results) {
		return []*models.Users{}, nil
	}

	end := offset + limit
	if end > len(results) {
		end = len(results)
	}

	results = results[start:end]

	return results, nil
}
