// Code generated by bizdb. DO NOT EDIT.
package repos

import (
	"errors"
	"fmt"
	"time"

	"github.com/chslink/bizdb"
	"{{.ModelImportPath}}"
)

var (
	Err{{.StructName}}NotFound = errors.New("{{.TableName}} not found")
)

type {{.StructName}}Repo struct {
	memDB     *bizdb.MemoryDB
	tableName string
	tx        *bizdb.Transaction
}

// New{{.StructName}}Repo 创建普通Repository
func New{{.StructName}}Repo(memDB *bizdb.MemoryDB) *{{.StructName}}Repo {
	return &{{.StructName}}Repo{
		memDB:     memDB,
		tableName: "{{.TableName}}",
	}
}

// WithTx 创建带事务的Repository
func (r *{{.StructName}}Repo) WithTx(tx *bizdb.Transaction) *{{.StructName}}Repo {
	return &{{.StructName}}Repo{
		memDB:     r.memDB,
		tableName: r.tableName,
		tx:        tx,
	}
}

type {{.StructName}}Query struct {
	{{- range .Fields}}
	{{.Name}} *{{.GoType}} {{.Tag}}
	{{- end}}
	Limit  *int
	Offset *int
}

// GetBy{{.PrimaryKey.Name}} 根据主键获取
func (r *{{.StructName}}Repo) GetBy{{.PrimaryKey.Name}}({{.PrimaryKey.Name}} {{.PrimaryKey.GoType}}) (*models.{{.StructName}}, error) {
	val, err := r.memDB.Get(r.tx, r.tableName, {{.PrimaryKey.Name}})
	if err != nil {
		return nil, err
	}

	if val == nil {
		return nil, Err{{.StructName}}NotFound
	}

	model, ok := val.(*models.{{.StructName}})
	if !ok {
		return nil, fmt.Errorf("type assertion failed")
	}

	return model.Copy(), nil
}

{{range .UniqueIndexes}}
// GetBy{{.FieldName}} 根据唯一索引查询
func (r *{{$.StructName}}Repo) GetBy{{.FieldName}}(val {{.FieldType}}) (*models.{{$.StructName}}, error) {
	query := {{$.StructName}}Query{
		{{.FieldName}}: &val,
	}

	results, err := r.Query(query)
	if err != nil {
		return nil, err
	}

	if len(results) == 0 {
		return nil, Err{{$.StructName}}NotFound
	}

	return results[0], nil
}
{{end}}

// Create 创建记录
func (r *{{.StructName}}Repo) Create(model *models.{{.StructName}}) error {

	if existing, _ := r.memDB.Get(r.tx, r.tableName, model.{{.PrimaryKey.Name}}); existing != nil {
		return fmt.Errorf("record with {{.PrimaryKey.Name}} %v already exists", model.{{.PrimaryKey.Name}})
	}

	return r.memDB.Put(r.tx, r.tableName, model.{{.PrimaryKey.Name}}, model.Copy())
}

// Update 更新记录
func (r *{{.StructName}}Repo) Update(model *models.{{.StructName}}) error {
	return r.memDB.Put(r.tx, r.tableName, model.{{.PrimaryKey.Name}}, model.Copy())
}

// Delete 删除记录
func (r *{{.StructName}}Repo) Delete({{.PrimaryKey.Name}} {{.PrimaryKey.GoType}}) error {
	return r.memDB.Delete(r.tx, r.tableName, {{.PrimaryKey.Name}})
}

// Range 遍历查询
func (r *{{.StructName}}Repo) Range(f func({{.PrimaryKey.Name}} {{.PrimaryKey.GoType}}, val *models.{{.StructName}}) bool) error {
	return r.memDB.Range(r.tx, r.tableName, func(id, val any) bool {
		return f(id.({{.PrimaryKey.GoType}}), val.(*models.{{.StructName}}))
	})
}

// Query 高级查询
func (r *{{.StructName}}Repo) Query(q {{.StructName}}Query) ([]*models.{{.StructName}}, error) {
	var results []*models.{{.StructName}}

	// 遍历匹配记录
	err := r.Range(func({{.PrimaryKey.Name}} {{.PrimaryKey.GoType}}, val *models.{{.StructName}}) bool {
		model := val

		// 组合查询条件（模板生成核心修改点）
		{{if .Fields}}
		if {{range $index, $field := .Fields}}{{if $index}} || {{end}}(q.{{$field.Name}} != nil && *q.{{$field.Name}} != model.{{$field.Name}}){{end}} {
			return true // 不匹配则继续
		}
		{{end}}

		results = append(results, model.Copy())
		return true
	})

	if err != nil {
		return nil, err
	}

	// 统一分页处理（模板结构调整）
	offset := 0
	if q.Offset != nil {
		offset = *q.Offset
	}

	limit := len(results) // 默认全量
	if q.Limit != nil {
		limit = *q.Limit
	}

	// 边界保护（新增模板逻辑）
	if offset < 0 {
		offset = 0
	}

	start := offset
	if start > len(results) {
		return []*models.{{.StructName}}{}, nil
	}

	end := offset + limit
	if end > len(results) {
		end = len(results)
	}

	results = results[start:end]

	return results, nil
}