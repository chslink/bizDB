// Code generated by bizdb. DO NOT EDIT.
package repos

import (
	"errors"
	"fmt"
	"time"

	"github.com/chslink/bizdb"
	"{{.ModelImportPath}}"
)

var (
	Err{{.StructName}}NotFound = errors.New("{{.TableName}} not found")
)

type {{.StructName}}Repo struct {
	memDB     *bizdb.MemoryDB
	tableName string
	tx        *bizdb.Transaction
}

// New{{.StructName}}Repo 创建普通Repository
func New{{.StructName}}Repo(memDB *bizdb.MemoryDB) *{{.StructName}}Repo {
	return &{{.StructName}}Repo{
		memDB:     memDB,
		tableName: "{{.TableName}}",
	}
}

// WithTx 创建带事务的Repository
func (r *{{.StructName}}Repo) WithTx(tx *bizdb.Transaction) *{{.StructName}}Repo {
	return &{{.StructName}}Repo{
		memDB:     r.memDB,
		tableName: r.tableName,
		tx:        tx,
	}
}

type {{.StructName}}Query struct {
	{{- range .Fields}}
	{{.Name}} *{{.GoType}} {{.Tag}}
	{{- end}}
	Limit  *int
	Offset *int
}

// GetBy{{.PrimaryKey.Name}} 根据主键获取
func (r *{{.StructName}}Repo) GetBy{{.PrimaryKey.Name}}({{.PrimaryKey.Name}} {{.PrimaryKey.GoType}}) (*models.{{.StructName}}, error) {
	val, err := r.memDB.Get(r.tx, r.tableName, {{.PrimaryKey.Name}})
	if err != nil {
		return nil, err
	}

	if val == nil {
		return nil, Err{{.StructName}}NotFound
	}

	model, ok := val.(*models.{{.StructName}})
	if !ok {
		return nil, fmt.Errorf("type assertion failed")
	}

	return model.Copy(), nil
}

{{range .UniqueIndexes}}
// GetBy{{.FieldName}} 根据唯一索引查询
func (r *{{$.StructName}}Repo) GetBy{{.FieldName}}(val {{.FieldType}}) (*models.{{$.StructName}}, error) {
	query := {{$.StructName}}Query{
		{{.FieldName}}: &val,
	}

	results, err := r.Query(query)
	if err != nil {
		return nil, err
	}

	if len(results) == 0 {
		return nil, Err{{$.StructName}}NotFound
	}

	return results[0], nil
}
{{end}}

// Create 创建记录
func (r *{{.StructName}}Repo) Create(model *models.{{.StructName}}) error {
	if r.tx == nil {
		return errors.New("write operation requires a transaction")
	}

	if existing, _ := r.memDB.Get(r.tx, r.tableName, model.{{.PrimaryKey.Name}}); existing != nil {
		return fmt.Errorf("record with {{.PrimaryKey.Name}} %v already exists", model.{{.PrimaryKey.Name}})
	}

	return r.memDB.Put(r.tx, r.tableName, model.{{.PrimaryKey.Name}}, model.Copy())
}

// Update 更新记录
func (r *{{.StructName}}Repo) Update(model *models.{{.StructName}}) error {
	if r.tx == nil {
		return errors.New("write operation requires a transaction")
	}

	if existing, _ := r.memDB.Get(r.tx, r.tableName, model.{{.PrimaryKey.Name}}); existing == nil {
		return Err{{.StructName}}NotFound
	}

	return r.memDB.Put(r.tx, r.tableName, model.{{.PrimaryKey.Name}}, model.Copy())
}

// Delete 删除记录
func (r *{{.StructName}}Repo) Delete({{.PrimaryKey.Name}} {{.PrimaryKey.GoType}}) error {
	if r.tx == nil {
		return errors.New("delete operation requires a transaction")
	}

	if existing, _ := r.memDB.Get(r.tx, r.tableName, {{.PrimaryKey.Name}}); existing == nil {
		return Err{{.StructName}}NotFound
	}

	return r.memDB.Delete(r.tx, r.tableName, {{.PrimaryKey.Name}})
}

// Range 遍历查询
func (r *{{.StructName}}Repo) Range(f func({{.PrimaryKey.Name}} {{.PrimaryKey.GoType}}, val *models.{{.StructName}}) bool) error {
	return r.memDB.Range(r.tx, r.tableName, func(id, val any) bool {
		return f(id.({{.PrimaryKey.GoType}}), val.(*models.{{.StructName}}))
	})
}

// Query 高级查询
func (r *{{.StructName}}Repo) Query(q {{.StructName}}Query) ([]*models.{{.StructName}}, error) {
	var results []*models.{{.StructName}}
	var end int

	// 分页处理
	if q.Limit != nil || q.Offset != nil {
		offset := 0
		if q.Offset != nil {
			offset = *q.Offset
		}
		limit := 0
		if q.Limit != nil {
			limit = *q.Limit
		}
		end = offset + limit
	}

	err := r.Range(func({{.PrimaryKey.Name}} {{.PrimaryKey.GoType}}, val *models.{{.StructName}}) bool {
		model := val
		match := true

		{{range .Fields}}
		if q.{{.Name}} != nil && *q.{{.Name}} != model.{{.Name}} {
			match = false
		}
		{{end}}

		if match {
			results = append(results, model.Copy())
		}

		if end > 0 && len(results) >= end {
			return false
		}
		return true
	})

	if err != nil {
		return nil, err
	}

	// 应用分页
	if q.Limit != nil || q.Offset != nil {
		offset := 0
		if q.Offset != nil {
			offset = *q.Offset
		}
		limit := len(results)
		if q.Limit != nil {
			limit = *q.Limit
		}

		end := offset + limit
		if end > len(results) {
			end = len(results)
		}

		if offset > len(results) {
			results = []*models.{{.StructName}}{}
		} else {
			results = results[offset:end]
		}
	}

	return results, nil
}
